"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[7993],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return h}});var i=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},r=Object.keys(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=i.createContext({}),p=function(e){var t=i.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(a),h=n,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||r;return a?i.createElement(m,o(o({ref:t},c),{},{components:a})):i.createElement(m,o({ref:t},c))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9095:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return d}});var i=a(3117),n=a(102),r=(a(7294),a(3905)),o=["components"],s={sidebar_position:1,title:"Preface"},l=void 0,p={unversionedId:"preface",id:"preface",title:"Preface",description:"1. The premise of the discussion",source:"@site/docs/preface.mdx",sourceDirName:".",slug:"/preface",permalink:"/jimmer/docs/preface",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/preface.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Preface"},sidebar:"tutorialSidebar",next:{title:"Tutorial introduction",permalink:"/jimmer/docs/intro"}},c={},d=[{value:"1. The premise of the discussion",id:"1-the-premise-of-the-discussion",level:2},{value:"2. Disadvantages of the current factions",id:"2-disadvantages-of-the-current-factions",level:2},{value:"2.1. Traditional ORM faction represented by JPA",id:"21-traditional-orm-faction-represented-by-jpa",level:3},{value:"2.2. DTO Mapper faction represented by MyBatis",id:"22-dto-mapper-faction-represented-by-mybatis",level:3},{value:"3. Advantages of Jimmer",id:"3-advantages-of-jimmer",level:2},{value:"3.1. No DTO Mode: Dynamic Entities",id:"31-no-dto-mode-dynamic-entities",level:3},{value:"3.2. Query arbitrarily complex data structures",id:"32-query-arbitrarily-complex-data-structures",level:3},{value:"3.3. Modify arbitrarily complex data structures",id:"33-modify-arbitrarily-complex-data-structures",level:3},{value:"3.3. Powerful caching mechanism",id:"33-powerful-caching-mechanism",level:3},{value:"3.4 Strongly typed SQL DSL more practical than native SQL",id:"34-strongly-typed-sql-dsl-more-practical-than-native-sql",level:3}],u={toc:d};function h(e){var t=e.components,a=(0,n.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"1-the-premise-of-the-discussion"},"1. The premise of the discussion"),(0,r.kt)("p",null,"A large part of the operations of OLTP type projects are aimed at the original data of the database. At this time, the object structure in the application is roughly the same as the data structure in the database, which is the scene discussed in this article."),(0,r.kt)("p",null,"The data types related to the calculation indicators introduced by business computing are not the same as the original structure of the database, and are not the scope of this article."),(0,r.kt)("h2",{id:"2-disadvantages-of-the-current-factions"},"2. Disadvantages of the current factions"),(0,r.kt)("p",null,"Now, there are many frameworks for users to access RDBMS, which are generally divided into two factions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Traditional ORM faction, JPA is the most well-known representative."),(0,r.kt)("li",{parentName:"ul"},"DTO Mapper faction, MyBatis is the most well-known representative.")),(0,r.kt)("h3",{id:"21-traditional-orm-faction-represented-by-jpa"},"2.1. Traditional ORM faction represented by JPA"),(0,r.kt)("p",null,"In traditional ORM, developers create entity classes that directly correspond to database table structures. From a mapping standpoint, it's pretty straightforward."),(0,r.kt)("p",null,"Traditional ORM focuses on maintaining the relationship between objects, taking JPA as an example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = entityManager\n    .createQuery(\n        "select book from Book book " +\n        "left join fetch book.store " +\n        "left join fetch book.authors",\n        Book.class\n    ).getResultList();\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"join fetch")," in this example is a feature of JPA, which can use ",(0,r.kt)("inlineCode",{parentName:"p"},"SQL JOIN")," to make the returned ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," object no longer a single object, but with associated properties ",(0,r.kt)("inlineCode",{parentName:"p"},"store")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"authors"),"."),(0,r.kt)("p",null,"Through the optional ",(0,r.kt)("inlineCode",{parentName:"p"},"join fetch"),(0,r.kt)("em",{parentName:"p"}," (or other tricks, different ORM frameworks support different ways)"),", the traditional ORM can return either a single data object or a complex object with associations, which is actually clipping capability of data structures."),(0,r.kt)("p",null,"This clipping capability is based on object granularity, but each object in the returned data structure is complete, that is to say, it lacks the clipping capability at the simple property level."),(0,r.kt)("p",null,"Simple property level clipping capability cannot be achieved. When there are many object properties so that the efficiency of querying all columns is very low, or when important properties need to be desensitized to low-privileged users, it will become a problem. Unfortunately, real projects are like this."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Although Hibernate starts from 3.x, simple (non-associative) properties can also be set to lazy. However, this feature is designed for lob properties, not for simple property level clipping, and the flexibility is very limited. not discussed")),(0,r.kt)("p",null,"If you want the traditional ORM to accurately implement property-level clipping, you will use code like this"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<BookDTO> bookDTOs = entityManager\n    .createQuery(\n        "select new BookDTO(book.id, book.name) " +\n        "from Book book",\n        BookDTO.class\n    ).getResultList();\n')),(0,r.kt)("p",null,"In this example, we only want to query the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," properties, we have to build a new type ",(0,r.kt)("inlineCode",{parentName:"p"},"BookDTO")," which is  used as a carrier for the mutilated object with only two properties. At the same time when we get the simple property-level clipping ability, because ",(0,r.kt)("inlineCode",{parentName:"p"},"BookDTO")," is a flat object rather than an entity object, the object-level clipping ability is lost."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"It is precisely because this usage loses the core capabilities of ORM that it is a non-mainstream usage in traditional ORM practice and is rarely used.")),(0,r.kt)("p",null,"Another problem with traditional ORMs is that the returned data is very complex and difficult to use directly."),(0,r.kt)("p",null,"For unloaded lazy properties, developers can easily ignore them in Json serialization, that's not a problem."),(0,r.kt)("p",null,"The real trouble is that there are two-way associations between objects, whereas front-end and microservice clients prefer to see a tree of objects with only one-way associations."),(0,r.kt)("p",null,"For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"TreeNode")," entity has both an upward ",(0,r.kt)("inlineCode",{parentName:"p"},"parent")," property and a downward ",(0,r.kt)("inlineCode",{parentName:"p"},"childNodes")," property."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Some businesses may need to query a node and all its subordinates, and return a data structure such as ",(0,r.kt)("inlineCode",{parentName:"li"},"aggregateRoot->childNodes->childNodes->..."),";"),(0,r.kt)("li",{parentName:"ul"},"Some businesses query a node and all its superiors, and return a data structure like ",(0,r.kt)("inlineCode",{parentName:"li"},"aggregateRoot->parent->parent->..."),".")),(0,r.kt)("p",null,"Therefore, you cannot simply specify which of ",(0,r.kt)("inlineCode",{parentName:"p"},"parent")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"childNodes")," is exposed and which is hidden. You can't solve this problem simply with the ",(0,r.kt)("inlineCode",{parentName:"p"},"@JsonIgnore")," annotation, it's a very tricky one."),(0,r.kt)("h3",{id:"22-dto-mapper-faction-represented-by-mybatis"},"2.2. DTO Mapper faction represented by MyBatis"),(0,r.kt)("p",null,"From the above description, we know that traditional ORM has two disadvantages."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The mainstream usage that facilitates the use of traditional ORM capabilities, although it has flexible object-level clipping capabilities, but it loses the simple property-level clipping capabilities."),(0,r.kt)("li",{parentName:"ol"},"The entity objects returned by the ORM are too complex to be returned directly and cannot interact with HTTP.")),(0,r.kt)("p",null,"These two problems are caused by the weak expressive ability of data objects. In fact, they can be solved by defining the DTO classes required by a specific business senarios."),(0,r.kt)("p",null,"Why write code to convert ORM entities to DTOs when people are destined to define specific business-related DTO types? Why not just implement the mapping from SQL results to DTOs directly?"),(0,r.kt)("p",null,"Therefore, the DTO Mapper faction is recognized by the developers, and this faction proposes a very different solution. Developers no longer define entity classes directly corresponding to the database structure, but directly define DTO types for each specific business senario, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create class ",(0,r.kt)("inlineCode",{parentName:"li"},"Book")," to express the lonely book objects"),(0,r.kt)("li",{parentName:"ul"},"Create class ",(0,r.kt)("inlineCode",{parentName:"li"},"BookWithStore")," to express the book objects with the associated property ",(0,r.kt)("inlineCode",{parentName:"li"},"store")),(0,r.kt)("li",{parentName:"ul"},"Create class ",(0,r.kt)("inlineCode",{parentName:"li"},"BookWithAuthors")," to express the book objects with the associated property ",(0,r.kt)("inlineCode",{parentName:"li"},"authors")),(0,r.kt)("li",{parentName:"ul"},"Create class ",(0,r.kt)("inlineCode",{parentName:"li"},"BookWithStoreAndAuthors")," to represent book objects with associated properties ",(0,r.kt)("inlineCode",{parentName:"li"},"store")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"authors"))),(0,r.kt)("p",null,"Each business API returns the DTO object it needs, and each API uses a specific SqlResultMapper to map specific query results to specific DTO."),(0,r.kt)("p",null,"However, this approach is equally problematic"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"In the above example, we only show object-level clipping, not simple property-level clipping, and the depth of the object tree is also very shallow. If not, the number of DTO types will be large, and it can even be described as ",(0,r.kt)("strong",{parentName:"p"},"exploding"),". At this time, there will be so many DTO classes that it is difficult to even get a name. Developers even need to incorporate industry-specific naming conventions to avoid very long class names.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"There are too many DTOs. Although different DTOs are different, they have many similar parts, which are highly redundant. The system loses compactness, and development and testing costs balloon.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Once new requirements are introduced, the structure of the database changes, and multiple redundant services need to be modified."))),(0,r.kt)("p",null,"To avoid problems 2 and 3, SQL mapper fragments or business code can be reused as much as possible, but this destroys the simplicity of the system and the code becomes difficult to understand, which is the inevitable price of excessive use of low-value reuse."),(0,r.kt)("h2",{id:"3-advantages-of-jimmer"},"3. Advantages of Jimmer"),(0,r.kt)("p",null,"From the above discussion, we know that"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Traditional ORM faction: The advantage is that it directly corresponds to the database structure and provides a unified perspective; but the disadvantage is that only object-level clipping is performed on the returned data format, and there is no simple property-level clipping, and the returned data structure is difficult to use directly."),(0,r.kt)("li",{parentName:"ul"},"DTO Mapper faction: The advantage is that the DTO object is simple, and the data structure represented by the returned aggregate root only contains one-way associations; but the disadvantage is that the number of DTO types is seriously inflated, although different but similar, the development cost and testing cost are both very high.")),(0,r.kt)("p",null,"Jimmer perfectly integrates the strengths of the two factions, and walks out of the another way. Therefore, Jimmer cannot be simply compared to any of solutation in the above factions."),(0,r.kt)("h3",{id:"31-no-dto-mode-dynamic-entities"},"3.1. No DTO Mode: Dynamic Entities"),(0,r.kt)("p",null,"In jimmer"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Entity objects are dynamic, any object property, whether simple or associated, can be missing."),(0,r.kt)("admonition",{parentName:"li",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"For Jimmer's entity objects, not specifying a property and specifying a property as null are two completely different things."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Directly reading missing properties of an object in Java or Kotlin code will result in an exception; however, when JSON serialization, missing properties are automatically ignored without exception.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Although two-way associations can be defined between different types when declaring entity types; however, when a specific business senario needs to instantiate objects, only one-way associations can be created between entity objects, ensuring that any data structure can use a simple aggregate root object to express."))),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Dynamic entity itself is not DTO, but it has all the characteristics of DTO object, any entity object tree can directly participate in HTTP interaction."),(0,r.kt)("p",{parentName:"admonition"},"Dynamic entities are the architectural foundation of the entire ORM.")),(0,r.kt)("h3",{id:"32-query-arbitrarily-complex-data-structures"},"3.2. Query arbitrarily complex data structures"),(0,r.kt)("p",null,"It perfectly supports object-level and simple property-level clipping capabilities. Users can delineate a local data structure from the complete relational model of database, that is, an arbitrarily complex tree structure, and query the entire data structure by returning a dynamic entity tree."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Let RDBMS have GraphQL-like functionality. Even if your project has nothing to do with GraphQL technology, your RDMBS has all its advantages."),(0,r.kt)("p",{parentName:"admonition"},"Jimmer does a better job than GraphQL, it even supports recursive queries on self-associative properties.")),(0,r.kt)("h3",{id:"33-modify-arbitrarily-complex-data-structures"},"3.3. Modify arbitrarily complex data structures"),(0,r.kt)("p",null,"Users can pass arbitrarily complex trees of dynamic objects to Jimmer, saving the entire tree in one sentence."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"It can be understood as the inverse function of GraphQL.")),(0,r.kt)("h3",{id:"33-powerful-caching-mechanism"},"3.3. Powerful caching mechanism"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"There is no restriction on the user's caching technology selection, and the user can choose any caching technology."),(0,r.kt)("li",{parentName:"ul"},"Internally supports object caching and associative caching, and in complex data structure queries, the two are organically combined on demand behind the scenes. The final effect presented to the user is a cache of arbitrary complex data structures, rather than a cache of simple objects."),(0,r.kt)("li",{parentName:"ul"},"Automatically guarantees the data consistency of cache, just simply call Jimmer's API after receiving the database binlog push."),(0,r.kt)("li",{parentName:"ul"},"The caching mechanism is 100% transparent to developers, and whether or not caching is used has no impact on business code.")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Although RDBMS has unparalleled expressive power, it has one obvious disadvantage: the performance of navigating and tracking other data according to the relationship is not ideal."),(0,r.kt)("p",{parentName:"admonition"},"Associative caching can alleviate this problem to a large extent and make RDBMS even more powerful.")),(0,r.kt)("h3",{id:"34-strongly-typed-sql-dsl-more-practical-than-native-sql"},"3.4 Strongly typed SQL DSL more practical than native SQL"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Found typos and type matching errors at compile time."),(0,r.kt)("li",{parentName:"ul"},"Strongly typed SQL DSL can be mixed with native SQL expressions at will, allowing the unique capabilities of specific database products to be used while unifying and abstracting different databases."),(0,r.kt)("li",{parentName:"ul"},"Provides multi-table join operations that are more convenient and practical than native SQL at the cost of abandoning individual SQL writing ways that are almost impossible to use in actual projects.")))}h.isMDXComponent=!0}}]);