"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[8782],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return m}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(t),m=i,h=p["".concat(s,".").concat(m)]||p[m]||u[m]||r;return t?a.createElement(h,l(l({ref:n},d),{},{components:t})):a.createElement(h,l({ref:n},d))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=p;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var c=2;c<r;c++)l[c]=t[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},5162:function(e,n,t){t.d(n,{Z:function(){return l}});var a=t(7294),i=t(4334),r="tabItem_Ymn6";function l(e){var n=e.children,t=e.hidden,l=e.className;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,l),hidden:t},n)}},5488:function(e,n,t){t.d(n,{Z:function(){return m}});var a=t(3117),i=t(7294),r=t(4334),l=t(2389),o=t(7392),s=t(7094),c=t(2466),d="tabList__CuJ",u="tabItem_LNqP";function p(e){var n,t,l=e.lazy,p=e.block,m=e.defaultValue,h=e.values,f=e.groupId,y=e.className,k=i.Children.map(e.children,(function(e){if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=h?h:k.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),b=(0,o.l)(g,(function(e,n){return e.value===n.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===m?m:null!=(n=null!=m?m:null==(t=k.find((function(e){return e.props.default})))?void 0:t.props.value)?n:k[0].props.value;if(null!==v&&!g.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+g.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var N=(0,s.U)(),C=N.tabGroupChoices,B=N.setTabGroupChoices,w=(0,i.useState)(v),T=w[0],x=w[1],S=[],j=(0,c.o5)().blockElementScrollPositionUntilNextRender;if(null!=f){var R=C[f];null!=R&&R!==T&&g.some((function(e){return e.value===R}))&&x(R)}var I=function(e){var n=e.currentTarget,t=S.indexOf(n),a=g[t].value;a!==T&&(j(n),x(a),null!=f&&B(f,String(a)))},A=function(e){var n,t=null;switch(e.key){case"ArrowRight":var a,i=S.indexOf(e.currentTarget)+1;t=null!=(a=S[i])?a:S[0];break;case"ArrowLeft":var r,l=S.indexOf(e.currentTarget)-1;t=null!=(r=S[l])?r:S[S.length-1]}null==(n=t)||n.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",d)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":p},y)},g.map((function(e){var n=e.value,t=e.label,l=e.attributes;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:T===n?0:-1,"aria-selected":T===n,key:n,ref:function(e){return S.push(e)},onKeyDown:A,onFocus:I,onClick:I},l,{className:(0,r.Z)("tabs__item",u,null==l?void 0:l.className,{"tabs__item--active":T===n})}),null!=t?t:n)}))),l?(0,i.cloneElement)(k.filter((function(e){return e.props.value===T}))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},k.map((function(e,n){return(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==T})}))))}function m(e){var n=(0,l.Z)();return i.createElement(p,(0,a.Z)({key:String(n)},e))}},1549:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return d},default:function(){return f},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return m}});var a=t(3117),i=t(102),r=(t(7294),t(3905)),l=t(5488),o=t(5162),s=["components"],c={sidebar_position:7,title:"External Cache"},d=void 0,u={unversionedId:"jimmer-sql/query/cache",id:"jimmer-sql/query/cache",title:"External Cache",description:"Work with any external cache. By default, the framework is just a very lightweight and powerful SQL generator without caching. Still, users can attach any external cache",source:"@site/docs/jimmer-sql/query/cache.mdx",sourceDirName:"jimmer-sql/query",slug:"/jimmer-sql/query/cache",permalink:"/jimmer/docs/jimmer-sql/query/cache",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/jimmer-sql/query/cache.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,title:"External Cache"},sidebar:"tutorialSidebar",previous:{title:"Query middle table",permalink:"/jimmer/docs/jimmer-sql/query/association"},next:{title:"Calculated property and its cache",permalink:"/jimmer/docs/jimmer-sql/query/calculated-prop"}},p={},m=[{value:"Basic concept",id:"basic-concept",level:2},{value:"1. Object cache",id:"1-object-cache",level:3},{value:"2. Reference association cache",id:"2-reference-association-cache",level:3},{value:"3. List association cache",id:"3-list-association-cache",level:3},{value:"4. Calculated property cache",id:"4-calculated-property-cache",level:3},{value:"Which functions will use the cache?",id:"which-functions-will-use-the-cache",level:2},{value:"Create cache",id:"create-cache",level:2},{value:"ChainCacheBuilder",id:"chaincachebuilder",level:3},{value:"1. LoadingBinder",id:"1-loadingbinder",level:4},{value:"2. SimpleBinder",id:"2-simplebinder",level:4},{value:"Configure cache",id:"configure-cache",level:2},{value:"Build RedisTemplate",id:"build-redistemplate",level:3},{value:"Explicit configuration",id:"explicit-configuration",level:3},{value:"1. Configure object cache",id:"1-configure-object-cache",level:4},{value:"2. Configure reference association cache",id:"2-configure-reference-association-cache",level:4},{value:"3. Configure list association cache",id:"3-configure-list-association-cache",level:4},{value:"4. Configure calculated cache",id:"4-configure-calculated-cache",level:4},{value:"Implicit configuration (recommended)",id:"implicit-configuration-recommended",level:3},{value:"Explicit configuration overrides implicit configuration",id:"explicit-configuration-overrides-implicit-configuration",level:3},{value:"Data consistency",id:"data-consistency",level:2},{value:"Environmental preparation",id:"environmental-preparation",level:3},{value:"Ensure data consistency",id:"ensure-data-consistency",level:3},{value:"Experience data consistency",id:"experience-data-consistency",level:3},{value:"1. Modify foreign key",id:"1-modify-foreign-key",level:4},{value:"2. Modify many-to-many association middle table",id:"2-modify-many-to-many-association-middle-table",level:4}],h={toc:m};function f(e){var n=e.components,t=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Work with any external cache. By default, the framework is just a very lightweight and powerful SQL generator without caching. Still, users can attach any external cache"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"No assumptions are made about the user's cache technology selection, developers can choose any cache technology. The framework only manages and coordinates the cache, and does not do cache implementation.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Unlike other ORMs, it supports not only object caching, but also associative caching. The two are combined behind the scenes and can be used with object fetcher to query object trees of any depth and breadth, especially when recursively querying self-associative properties."))),(0,r.kt)("p",null,"For high-performance complex data structure queries, the following two tasks will cause a large workload for developers."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Query different data fragments from different caches, and then manually merge them into a whole and return it.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Ensure consistency between cache and database."))),(0,r.kt)("p",null,"In order to relieve the developer from these two heavy tasks, the framework's caching mechanism is designed to be powerful enough and transparent to the developer."),(0,r.kt)("h2",{id:"basic-concept"},"Basic concept"),(0,r.kt)("h3",{id:"1-object-cache"},"1. Object cache"),(0,r.kt)("p",null,"This cache maps ids to entity objects, which are simple objects without associations(Except for id-only parent objects based on foreign key)."),(0,r.kt)("p",null,"Examples"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"key"),(0,r.kt)("th",{parentName:"tr",align:null},"value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BookStore-1"),(0,r.kt)("td",{parentName:"tr",align:null},'{"id":1,"name":"O\'REILLY","website":null}')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Book-1"),(0,r.kt)("td",{parentName:"tr",align:null},'{"id":1,"name":"Learning GraphQL","edition":1,"price":50.00,"store":{"id":1}}')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Book-2"),(0,r.kt)("td",{parentName:"tr",align:null},'{"id":2,"name":"Learning GraphQL","edition":2,"price":55.00,"store":{"id":1}}')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Book-3"),(0,r.kt)("td",{parentName:"tr",align:null},'{"id":3,"name":"Learning GraphQL","edition":3,"price":51.00,"store":{"id":1}}')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Author-1"),(0,r.kt)("td",{parentName:"tr",align:null},'{"id":1,"firstName":"Eve","lastName":"Procello","gender":"FEMALE"}')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Author-2"),(0,r.kt)("td",{parentName:"tr",align:null},'{"id":2,"firstName":"Alex","lastName":"Banks","gender":"MALE"}')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TreeNode-1"),(0,r.kt)("td",{parentName:"tr",align:null},'{"id":1,"name":"Home","parent":null}')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TreeNode-2"),(0,r.kt)("td",{parentName:"tr",align:null},'{"id":2,"name":"Food","parent":{"id":1}}')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TreeNode-9"),(0,r.kt)("td",{parentName:"tr",align:null},'{"id":9,"name":"Clothing","parent":{"id":1}}')))),(0,r.kt)("h3",{id:"2-reference-association-cache"},"2. Reference association cache"),(0,r.kt)("p",null,"This cache is used for one-to-one and many-to-one associations, mapping the current object id to the id of the associated object"),(0,r.kt)("p",null,"Examples"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"key"),(0,r.kt)("th",{parentName:"tr",align:null},"value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Book.store-1"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Book.store-2"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Book.store-3"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TreeNode.parent-2"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TreeNode.parent-9"),(0,r.kt)("td",{parentName:"tr",align:null},"1")))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Note: If the current association is a many-to-one association based on a foreign key, and the current object has explicitly included the foreign key property, the cache will not be used.")),(0,r.kt)("h3",{id:"3-list-association-cache"},"3. List association cache"),(0,r.kt)("p",null,"This cache is used for one-to-many and many-to-many associations, mapping the current object id to a list of associated object ids"),(0,r.kt)("p",null,"Examples"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"key"),(0,r.kt)("th",{parentName:"tr",align:null},"value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BookStore.books-1"),(0,r.kt)("td",{parentName:"tr",align:null},"[1, 2, 3]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Book.authors-1"),(0,r.kt)("td",{parentName:"tr",align:null},"[1, 2]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Book.authors-2"),(0,r.kt)("td",{parentName:"tr",align:null},"[1, 2]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Book.authors-3"),(0,r.kt)("td",{parentName:"tr",align:null},"[1, 2]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Author.books-1"),(0,r.kt)("td",{parentName:"tr",align:null},"[1, 2, 3]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Author.books-2"),(0,r.kt)("td",{parentName:"tr",align:null},"[1, 2, 3]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TreeNode.childNodes-1"),(0,r.kt)("td",{parentName:"tr",align:null},"[9, 2]")))),(0,r.kt)("h3",{id:"4-calculated-property-cache"},"4. Calculated property cache"),(0,r.kt)("p",null,"This cache is used for user-defined calculated properties. "),(0,r.kt)("p",null,"This cache will be explained in detail in the article ",(0,r.kt)("a",{parentName:"p",href:"./calculated-prop"},"Calculated property and its cache"),", and this article will not pay attention to it."),(0,r.kt)("h2",{id:"which-functions-will-use-the-cache"},"Which functions will use the cache?"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Object fetcher: Except for the root query, the rest of the associations and associated objects will use the cache, which is extremely effective for recursive fetching."),(0,r.kt)("li",{parentName:"ol"},"GraphQL query: Except for the root query, the rest of the associations and associated objects will use the cache."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"findById"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"findByIds")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"findMapByIds")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"sqlClient.entities"),".")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Using a cache or not can cause advanced queries like ",(0,r.kt)("inlineCode",{parentName:"p"},"object fetch")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"GraphQL")," to generate very different final SQL. But their final effect is equivalent.")),(0,r.kt)("h2",{id:"create-cache"},"Create cache"),(0,r.kt)("p",null,"Before configuring the cache for the ORM, the cache object needs to be created first."),(0,r.kt)("p",null,"jimmer-sql does not make any assumptions about the caching technology that users use. Users can use any caching technology, as long as it is adapted to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Cache")," interface."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Cache.java"',title:'"Cache.java"'},"package org.babyfish.jimmer.sql.cache;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Map;\n\npublic interface Cache<K, V> {\n\n    @Nullable V get(@NotNull K key, @NotNull CacheEnvironment<K, V> env);\n\n    @NotNull Map<K, V> getAll(@NotNull Collection<K> keys, @NotNull CacheEnvironment<K, V> env);\n\n    void delete(@NotNull K key);\n\n    void delete(@NotNull K key, Object reason);\n\n    void deleteAll(@NotNull Collection<K> keys);\n\n    void deleteAll(@NotNull Collection<K> keys, @Nullable Object reason);\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"In fact, users do not need to implement this interface directly, using ",(0,r.kt)("inlineCode",{parentName:"strong"},"ChainCacheBuilder")," to create cache instances is a more recommended pattern.")),(0,r.kt)("h3",{id:"chaincachebuilder"},"ChainCacheBuilder"),(0,r.kt)("p",null,"In practical projects, caches are often multi-level, and ChainCacheBuilder is used to help users quickly build multi-level caches."),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"Cache<K, V> cache = new ChainCacheBuilder<>()\n    .add(new CaffeineBinder<>(512, Duration.ofSeconds(1)))\n    .add(new RedisBinder<>(redisTemplate, type, Duration.ofMinutes(10)))\n    .build();\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val cache = ChainCacheBuilder<Any, Any>()\n    .add(CaffeineBinder(512, Duration.ofSeconds(1)))\n    .add(RedisBinder(redisTemplate, type, Duration.ofMinutes(10)))\n    .build()\n")))),(0,r.kt)("p",null,"In this example, we build a two-level caches."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The first-level cache is a memory cache inside the JVM, implemented based on caffeine.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The second level cache is a sharable distributed memory cache based on redis."))),(0,r.kt)("p",null,"As mentioned above, jimmer-sql does not make any assumptions about the cache technology used by the user. The ",(0,r.kt)("inlineCode",{parentName:"p"},"CaffeineBinder")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"RedisBinder")," in the above code are not the types provided by the framework, but the types implemented by user."),(0,r.kt)("p",null,"Users can choose their favorite caching technologies at will, and write ",(0,r.kt)("inlineCode",{parentName:"p"},"Binder")," adaptation classes for them. These adaptation types need to implement the interface provided by jimmer-sql: ",(0,r.kt)("inlineCode",{parentName:"p"},"LoadingBinder")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"SimpleBinder"),"."),(0,r.kt)("h4",{id:"1-loadingbinder"},"1. LoadingBinder"),(0,r.kt)("p",null,"Some caching technologies, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"Caffeine")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Guava"),", can determine by themselves whether the queried data already exists, and if not, automatically load it from the database or the next level cache."),(0,r.kt)("p",null,"For this type of caching technology, its adapter class should implement the interface ",(0,r.kt)("inlineCode",{parentName:"p"},"LoadingBinder"),"."),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="CaffeineBinder.java"',title:'"CaffeineBinder.java"'},'public class CaffeineBinder<K, V> implements LoadingBinder<K, V> {\n\n    private final int maximumSize;\n\n    private final Duration duration;\n\n    // Caffeine does not support null value, \n    // use `Ref<V>` as a wrapper\n    private LoadingCache<K, Ref<V>> loadingCache;\n\n    public CaffeineBinder(int maximumSize, Duration duration) {\n        this.maximumSize = maximumSize;\n        this.duration = duration;\n    }\n\n    @Override\n    public void initialize(\n        // `chain` tells caffine how to load the non-existing \n        // data from database or next level cache.\n        CacheChain<K, V> chain\n    ) {\n        // Create caffeine cache\n        loadingCache = Caffeine\n                .newBuilder()\n                .maximumSize(maximumSize)\n                .expireAfterWrite(duration)\n                .build(\n                    new CacheLoader<K, Ref<V>>() {\n\n                        @Override\n                        public Ref<V> load(K key) {\n                            // Load from database or next level cache\n                            Map<K, V> map = chain.loadAll(Collections.singleton(key));\n                            V value = map.get(key);\n                            if (value != null || map.containsKey(key)) {\n                                return Ref.of(value);\n                            }\n                            return null;\n                        }\n\n                        @SuppressWarnings("unchecked")\n                        @Override\n                        public Map<? extends K, ? extends Ref<V>> loadAll(\n                            Set<? extends K> keys\n                        ) {\n                            // Load from database or next level cache\n                            Map<K, V> map = chain.loadAll((Collection<K>) keys);\n                            return map\n                                    .entrySet()\n                                    .stream()\n                                    .collect(\n                                            Collectors.toMap(\n                                                    Map.Entry::getKey,\n                                                    e -> Ref.of(e.getValue())\n                                            )\n                                    );\n                        }\n                    }\n                );\n    }\n\n    @Override\n    public Map<K, V> getAll(Collection<K> keys) {\n        Map<K, Ref<V>> map = loadingCache.getAll(keys);\n        Map<K, V> convertedMap = new HashMap<>((map.size() * 4 + 2) / 3);\n        for (Map.Entry<K, Ref<V>> e : map.entrySet()) {\n            convertedMap.put(e.getKey(), e.getValue().getValue());\n        }\n        return convertedMap;\n    }\n\n    @Override\n    public void deleteAll(@NotNull Collection<K> keys, Object reason) {\n        // If user want delete keys from \n        // 1. all sub caches in the cache chain\n        // 2. or caffeine sub cache.\n        if (reason == null || reason.equals("caffeine")) {\n            loadingCache.invalidateAll(keys);\n        }\n    }\n}\n'))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="CaffeineBinder.kt"',title:'"CaffeineBinder.kt"'},'class CaffeineBinder<K: Any, V: Any>(\n    private val maximumSize: Int, \n    private val duration: Duration\n) : LoadingBinder<K, V> {\n    \n    // Caffeine does not support null value, \n    // use `Ref<V>` as a wrapper\n    private lateinit var loadingCache: LoadingCache<K, Ref<V>>\n    \n    override fun initialize(\n        // `chain` tells caffine how to load the non-existing \n        // data from database or next level cache.\n        chain: CacheChain<K, V>\n    ) {\n        // Create caffeine cache\n        loadingCache = Caffeine\n            .newBuilder()\n            .maximumSize(maximumSize.toLong())\n            .expireAfterWrite(duration)\n            .build(\n                object : CacheLoader<K, Ref<V>> {\n                    override fun load(key: K): Ref<V>? {\n                        // Load from database or next level cache\n                        val map = chain.loadAll(setOf(key))\n                        val value = map[key]\n                        return if (value != null || map.containsKey(key)) {\n                            Ref.of(value)\n                        } else {\n                            null\n                        }\n                    }\n\n                    override fun loadAll(keys: Set<K>): Map<out K, Ref<V>> =\n                        // Load from database or next level cache\n                        chain.loadAll((keys as Collection<K>)).mapValues {\n                            Ref.of(it.value)\n                        }\n                }\n            )\n    }\n\n    override fun getAll(keys: Collection<K>): Map<K, V?> =\n        loadingCache.getAll(keys).mapValues {\n            it.value.value\n        }\n\n    override fun deleteAll(keys: Collection<K>, reason: Any?) {\n        // If user want delete keys from \n        // 1. all sub caches in the cache chain\n        // 2. or caffeine sub cache.\n        if (reason === null || reason == "caffeine") {\n            loadingCache.invalidateAll(keys)\n        }\n    }\n}\n')))),(0,r.kt)("h4",{id:"2-simplebinder"},"2. SimpleBinder"),(0,r.kt)("p",null,"Some caching technologies, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"Redis"),", only support get/set operations, requiring developers to determine whether the queried data already exists, and if not, the developers load it from the database or the next-level cache."),(0,r.kt)("p",null,"For this type of caching technology, the adapter class should implement the interface ",(0,r.kt)("inlineCode",{parentName:"p"},"SimpleBinder"),"."),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="RedisBinder.java"',title:'"RedisBinder.java"'},"public class RedisBinder<K, V> implements SimpleBinder<K, V> {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RedisBinder.class);\n\n    private final RedisOperations<String, byte[]> operations;\n\n    private final String keyPrefix;\n\n    private final Duration duration;\n\n    private final int randomPercent;\n\n    // For cached values, don't use spring-redis's RedisSerializer, \n    // use `org.babyfish.jimmer.sql.cache.ValueSerializer`.\n    // \n    // Its internal work has a certain complexity, \n    // and it is not easy to be implemented by user.\n    private final ValueSerializer<V> valueSerializer;\n\n    public RedisBinder(\n            RedisOperations<String, byte[]> operations,\n            ImmutableType type,\n            Duration duration\n    ) {\n        this(operations, type, duration, 30);\n    }\n\n    public RedisBinder(\n            RedisOperations<String, byte[]> operations,\n            ImmutableProp prop,\n            Duration duration\n    ) {\n        this(operations, prop, duration, 30);\n    }\n\n    public RedisBinder(\n            RedisOperations<String, byte[]> operations,\n            ImmutableProp prop,\n            Duration duration,\n            int randomPercent\n    ) {\n        this(operations, null, prop, duration, randomPercent);\n    }\n\n    public RedisBinder(\n            RedisOperations<String, byte[]> operations,\n            ImmutableType type,\n            Duration duration,\n            int randomPercent\n    ) {\n        this(operations, type, null, duration, randomPercent);\n    }\n\n    private RedisBinder(\n            RedisOperations<String, byte[]> operations,\n            ImmutableType type,\n            ImmutableProp prop,\n            Duration duration,\n            int randomPercent\n    ) {\n        if ((type == null) == (prop == null)) {\n            throw new IllegalArgumentException(\"Illegal metadata\");\n        }\n        if (randomPercent < 0 || randomPercent > 100) {\n            throw new IllegalArgumentException(\"randomPercent must between 0 and 100\");\n        }\n        this.operations = operations;\n        if (type != null) {\n            // Prefix for object, for example: 'Book-'\n            this.keyPrefix = type.getJavaClass().getSimpleName() + '-';\n        } else {\n            // Prefix for property, for example: 'Book.authors-'\n            this.keyPrefix = \n                prop.getDeclaringType().getJavaClass().getSimpleName() + \n                '.' + \n                prop.getName() + \n                '-';\n        }\n        this.duration = duration;\n        this.randomPercent = randomPercent;\n        if (type != null) {\n            valueSerializer = new ValueSerializer<>(type);\n        } else {\n            valueSerializer = new ValueSerializer<>(prop);\n        }\n    }\n\n    // How to read value from redis\n    @Override\n    public Map<K, V> getAll(Collection<K> keys) {\n        List<byte[]> values = operations\n            .opsForValue()\n            .multiGet(\n                keys.stream()\n                .map(it -> keyPrefix + it)\n                .collect(Collectors.toList())\n            );\n        return valueSerializer.deserialize(keys, values);\n    }\n\n    // How to set value into redis\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void setAll(Map<K, V> map) {\n        Map<String, byte[]> convertedMap = \n            valueSerializer.serialize(map, key -> keyPrefix + key);\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(\"save into redis: {}\", convertedMap.keySet());\n        }\n        long millis = duration.toMillis();\n        long min = millis - randomPercent * millis / 100;\n        long max = millis + randomPercent * millis / 100;\n        ThreadLocalRandom random = ThreadLocalRandom.current();\n        operations.executePipelined(\n                new SessionCallback<Void>() {\n                    @Override\n                    public <XK, XV> Void execute(\n                        RedisOperations<XK, XV> pops\n                    ) throws DataAccessException {\n                        RedisOperations<String, byte[]> pipelinedOps = \n                            (RedisOperations<String, byte[]>)pops;\n                        pipelinedOps.opsForValue().multiSet(convertedMap);\n                        for (String key : convertedMap.keySet()) {\n                            pipelinedOps.expire(\n                                    key,\n                                    random.nextLong(min, max),\n                                    TimeUnit.MILLISECONDS\n                            );\n                        }\n                        return null;\n                    }\n                }\n        );\n    }\n\n    @Override\n    public void deleteAll(Collection<K> keys, Object reason) {\n        // If user want delete keys from \n        // 1. all sub caches in the cache chain\n        // 2. or redis sub cache.\n        if (reason == null || reason.equals(\"redis\")) {\n            Collection<String> redisKeys = \n                keys\n                    .stream()\n                    .map(it -> keyPrefix + it)\n                    .collect(Collectors.toList());\n            LOGGER.info(\"delete from redis: {}\", redisKeys);\n            operations.delete(redisKeys);\n        }\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="RedisBinder.kt"',title:'"RedisBinder.kt"'},'class RedisBinder<K, V> private constructor(\n    operations: RedisOperations<String, ByteArray>,\n    type: ImmutableType?,\n    prop: ImmutableProp?,\n    duration: Duration,\n    randomPercent: Int\n) : SimpleBinder<K, V> {\n\n    private val operations: RedisOperations<String, ByteArray>\n\n    private val keyPrefix: String\n\n    private val duration: Duration\n\n    private val randomPercent: Int\n\n    // For cached values, don\'t use spring-redis\'s RedisSerializer, \n    // use `org.babyfish.jimmer.sql.cache.ValueSerializer`.\n    // \n    // Its internal work has a certain complexity, \n    // and it is not easy to be implemented by user.\n    private var valueSerializer: ValueSerializer<V>\n\n    init {\n        require(type == null != (prop == null)) { \n            "Illegal metadata" \n        }\n        require(!(randomPercent < 0 || randomPercent > 100)) { \n            "randomPercent must between 0 and 100" \n        }\n        this.operations = operations\n        keyPrefix = if (type != null) {\n            // Prefix for object, for example: \'Book-\'\n            "${type.javaClass.simpleName}-"\n        } else {\n            // Prefix for property, for example: \'Book.authors-\'\n            "${prop!!.declaringType.javaClass.simpleName}.${prop.name}-"\n        }\n        this.duration = duration\n        this.randomPercent = randomPercent\n        valueSerializer = type\n            ?.let { ValueSerializer(it) } \n            ?: ValueSerializer(prop!!)\n    }\n\n    constructor(\n        operations: RedisOperations<String, ByteArray>,\n        type: ImmutableType,\n        duration: Duration,\n        randomPercent: Int = 30\n    ) : this(operations, type, null, duration, randomPercent)\n\n    constructor(\n        operations: RedisOperations<String, ByteArray>,\n        prop: ImmutableProp,\n        duration: Duration,\n        randomPercent: Int = 30\n    ) : this(operations, null, prop, duration, randomPercent)\n\n    // How to read value from redis\n    override fun getAll(keys: Collection<K>): Map<K, V> {\n        val values = operations.opsForValue().multiGet(\n            keys.map { "$keyPrefix$it" }\n        )\n        return valueSerializer.deserialize(keys, values!!)\n    }\n\n    // How to set value into redis\n    @Suppress("UNCHECKED_CAST")\n    override fun setAll(map: Map<K, V>) {\n        val convertedMap = valueSerializer.serialize(map) { "$keyPrefix$it" }\n        if (LOGGER.isInfoEnabled) {\n            LOGGER.info("save into redis: {}", convertedMap.keys)\n        }\n        val millis = duration.toMillis()\n        val min = millis - randomPercent * millis / 100\n        val max = millis + randomPercent * millis / 100\n        val random = ThreadLocalRandom.current()\n        operations.executePipelined(\n            object : SessionCallback<Void?> {\n                override fun <XK, XV> execute(pops: RedisOperations<XK, XV>): Void? {\n                    val pipelinedOps = pops as RedisOperations<String, ByteArray>\n                    pipelinedOps.opsForValue().multiSet(convertedMap)\n                    for (key in convertedMap.keys) {\n                        pipelinedOps.expire(\n                            key,\n                            random.nextLong(min, max),\n                            TimeUnit.MILLISECONDS\n                        )\n                    }\n                    return null\n                }\n            }\n        )\n    }\n\n    override fun deleteAll(keys: Collection<K>, reason: Any?) {\n        // If user want delete keys from \n        // 1. all sub caches in the cache chain\n        // 2. or redis sub cache.\n        if (reason === null || reason == "redis") {\n            val redisKeys: Collection<String> = keys.map { "$keyPrefix$it" }\n            LOGGER.info("delete from redis: {}", redisKeys)\n            operations.delete(redisKeys)\n        }\n    }\n\n    companion object {\n        private val LOGGER = LoggerFactory.getLogger(RedisBinder::class.java)\n    }\n}\n')))),(0,r.kt)("h2",{id:"configure-cache"},"Configure cache"),(0,r.kt)("h3",{id:"build-redistemplate"},"Build RedisTemplate"),(0,r.kt)("p",null,"In this example, our second level cache uses redis, so we need to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"RedisTemplate")," first"),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Bean\npublic RedisTemplate<String, byte[]> rawDataRedisTemplate(\n    // Inject connection factory of spring data redis\n    RedisConnectionFactory connectionFactory\n) {\n    RedisTemplate<String, byte[]> template = new RedisTemplate<>();\n    template.setConnectionFactory(connectionFactory);\n    template.setKeySerializer(StringRedisSerializer.UTF_8);\n\n    // Specify a dummy serializer for spring redis because \n    // `org.babyfish.jimmer.sql.example.cache.ValueSerializer` took over the job.\n    template.setValueSerializer(\n            new RedisSerializer<byte[]>() {\n                @Override\n                public byte[] serialize(byte[] bytes) throws SerializationException {\n                    return bytes;\n                }\n                @Override\n                public byte[] deserialize(byte[] bytes) throws SerializationException {\n                    return bytes;\n                }\n            }\n    );\n    return template;\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Bean\nfun rawDataRedisTemplate(\n    // Inject connection factory of spring data redis\n    connectionFactory: RedisConnectionFactory\n): RedisTemplate<String, ByteArray> =\n    RedisTemplate<String, ByteArray>().apply {\n        setConnectionFactory(connectionFactory)\n        keySerializer = StringRedisSerializer.UTF_8\n\n        // Specify a dummy serializer for spring redis because\n        // `org.babyfish.jimmer.sql.example.cache.ValueSerializer` took over the job.\n        valueSerializer =\n            object : RedisSerializer<ByteArray?> {\n                override fun serialize(t: ByteArray?): ByteArray? = t\n                override fun deserialize(bytes: ByteArray?): ByteArray? = bytes\n            }\n    }\n")))),(0,r.kt)("p",null,"There are two ways to configure cache for jimmer-sql, explicit configuration and implicit configuration."),(0,r.kt)("h3",{id:"explicit-configuration"},"Explicit configuration"),(0,r.kt)("h4",{id:"1-configure-object-cache"},"1. Configure object cache"),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Bean\npublic JSqlClient sqlClient(\n    RedisTemplate<String, byte[]> redisTemplate\n) {\n    return JSqlClient\n        .newBuilder()\n        .setCaches(it -> {\n            // highlight-next-line\n            it.setObjectCache(\n                Book.class,\n                new ChainCacheBuilder<>()\n                    .add(\n                        new CaffeineBinder<>(\n                            512, \n                            Duration.ofSeconds(1)\n                        )\n                    )\n                    .add(\n                        new RedisBinder<>(\n                            redisTemplate, \n                            type, \n                            Duration.ofMinutes(10)\n                        )\n                    )\n                    .build()\n            );\n        })\n        ...omit other configuration...\n        .build()\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Bean\nfun sqlClient(\n    redisTemplate: RedisTemplate<String, ByteArray>\n): KSqlClient =\n    newKSqlClient {\n        setCaches {\n            // highlight-next-line\n            setObjectCache(\n                Book::class,\n                ChainCacheBuilder<Any, Any>()\n                .add(\n                    CaffeineBinder(\n                        512, \n                        Duration.ofSeconds(1)\n                    )\n                )\n                .add(\n                    RedisBinder(\n                        redisTemplate, \n                        type, \n                        Duration.ofMinutes(10)\n                    )\n                )\n                .build()\n            )\n        }\n        ...omit other configuration...\n    }\n")))),(0,r.kt)("h4",{id:"2-configure-reference-association-cache"},"2. Configure reference association cache"),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Bean\npublic JSqlClient sqlClient(\n    RedisTemplate<String, byte[]> redisTemplate\n) {\n    return JSqlClient\n        .newBuilder()\n        .setCaches(it -> {\n            // highlight-next-line\n            it.setAssociatedIdCache(\n                BookProps.STORE,\n                new ChainCacheBuilder<>()\n                    .add(\n                        new CaffeineBinder<>(\n                            512, \n                            Duration.ofSeconds(1)\n                        )\n                    )\n                    .add(\n                        new RedisBinder<>(\n                            redisTemplate, \n                            type, \n                            Duration.ofMinutes(5)\n                        )\n                    )\n                    .build()\n            );\n        })\n        ...omit other configuration...\n        .build()\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Bean\nfun sqlClient(\n    redisTemplate: RedisTemplate<String, ByteArray>\n): KSqlClient =\n    newKSqlClient {\n        setCaches {\n            // highlight-next-line\n            setAssociatedIdCache(\n                Book::store,\n                ChainCacheBuilder<Any, Any>()\n                .add(\n                    CaffeineBinder(\n                        512, \n                        Duration.ofSeconds(1)\n                    )\n                )\n                .add(\n                    RedisBinder(\n                        redisTemplate, \n                        type, \n                        Duration.ofMinutes(5)\n                    )\n                )\n                .build()\n            )\n        }\n        ...omit other configuration...\n    }\n")))),(0,r.kt)("h4",{id:"3-configure-list-association-cache"},"3. Configure list association cache"),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Bean\npublic JSqlClient sqlClient(\n    RedisTemplate<String, byte[]> redisTemplate\n) {\n    return JSqlClient\n        .newBuilder()\n        .setCaches(it -> {\n            // highlight-next-line\n            it.setAssociatedIdListCache(\n                BookProps.AUTHORS,\n                new ChainCacheBuilder<Object, List<?>>()\n                    .add(\n                        new CaffeineBinder<>(\n                            512, \n                            Duration.ofSeconds(1)\n                        )\n                    )\n                    .add(\n                        new RedisBinder<>(\n                            redisTemplate, \n                            type, \n                            Duration.ofMinutes(5)\n                        )\n                    )\n                    .build()\n            );\n        })\n        ...omit other configuration...\n        .build()\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Bean\nfun sqlClient(\n    redisTemplate: RedisTemplate<String, ByteArray>\n): KSqlClient =\n    newKSqlClient {\n        setCaches {\n            // highlight-next-line\n            setAssociatedIdListCache(\n                Book::authors,\n                ChainCacheBuilder<Any, List<Any>>()\n                .add(\n                    CaffeineBinder(\n                        512, \n                        Duration.ofSeconds(1)\n                    )\n                )\n                .add(\n                    RedisBinder(\n                        redisTemplate, \n                        type, \n                        Duration.ofMinutes(5)\n                    )\n                )\n                .build()\n            )\n        }\n        ...omit other configuration...\n    }\n")))),(0,r.kt)("h4",{id:"4-configure-calculated-cache"},"4. Configure calculated cache"),(0,r.kt)("p",null,"This cache will be explained in detail in the article ",(0,r.kt)("a",{parentName:"p",href:"./calculated-prop"},"Calculated property and its cache"),", and this article will not pay attention to it."),(0,r.kt)("h3",{id:"implicit-configuration-recommended"},"Implicit configuration (recommended)"),(0,r.kt)("p",null,"From the previous description, we can specify an object cache for any type, and an association cache for any property."),(0,r.kt)("p",null,"However, in actual projects, there may be many entity types and association properties, and configuring them one by one will be very tedious. Implicit configuration can handle this situation well."),(0,r.kt)("p",null,"Implicit configuration requires the help of the interface ",(0,r.kt)("inlineCode",{parentName:"p"},"CacheFactory")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public interface CacheFactory {\n\n    @Nullable\n    default Cache<?, ?> createObjectCache(\n        @NotNull ImmutableType type\n    ) {\n        return null;\n    }\n\n    @Nullable\n    default Cache<?, ?> createAssociatedIdCache(\n        @NotNull ImmutableProp prop\n    ) {\n        return null;\n    }\n\n    @Nullable\n    default Cache<?, List<?>> createAssociatedIdListCache(\n        @NotNull ImmutableProp prop\n    ) {\n        return null;\n    }\n\n    @Nullable\n    default Cache<?, ?> createResolverCache(\n        @NotNull ImmutableProp prop\n    ) {\n        return null;\n    }\n}\n")),(0,r.kt)("p",null,"The usage is as follows"),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Bean\npublic JSqlClient sqlClient(\n    RedisTemplate<String, byte[]> redisTemplate\n) {\n    return JSqlClient\n        .newBuilder()\n        .setCaches(it -> {\n            // highlight-next-line\n            setCacheFactory(\n                \n                // Use this array to iterate types, \n                // association properties, and calculated properties.\n                new Class[] {\n                    BookStore.class,\n                    Book.class,\n                    Author.class,\n                    TreeNode.class\n                }\n\n                // For each type and property, create optional cache.\n                return new CacheFactory() {\n\n                    // Create object cache for types, including:\n                    // `BookStore`\n                    // `Book`\n                    // `Author`\n                    /// `TreeNode` \n                    @Override\n                    public Cache<?, ?> createObjectCache(ImmutableType type) {\n                        return new ChainCacheBuilder<>()\n                                .add(\n                                    new CaffeineBinder<>(\n                                        512, \n                                        Duration.ofSeconds(1)\n                                    )\n                                )\n                                .add(\n                                    new RedisBinder<>(\n                                        redisTemplate, \n                                        type, \n                                        Duration.ofMinutes(10)\n                                    )\n                                )\n                                .build();\n                    }\n\n                    // Create reference association cache for \n                    // one-to-one/many-to-one properties, including:\n                    // `Book.store`\n                    // `TreeNode.parent`\n                    @Override\n                    public Cache<?, ?> createAssociatedIdCache(ImmutableProp prop) {\n                        return new ChainCacheBuilder<>()\n                                .add(\n                                    new CaffeineBinder<>(\n                                        512, \n                                        Duration.ofSeconds(1)\n                                    )\n                                )\n                                .add(\n                                    new RedisBinder<>(\n                                        redisTemplate, \n                                        prop, \n                                        Duration.ofMinutes(5)\n                                    )\n                                )\n                                .build();\n                    }\n\n                    // Create list association cache for \n                    // one-to-many/many-to-many properties, including:\n                    // `BookStore.books`\n                    // `Book.authors`\n                    // `Author.books`\n                    // `TreeNode.childNodes`\n                    @Override\n                    public Cache<?, List<?>> createAssociatedIdListCache(ImmutableProp prop) {\n                        return new ChainCacheBuilder<Object, List<?>>()\n                                .add(\n                                    new CaffeineBinder<>(\n                                        64, \n                                        Duration.ofSeconds(1)\n                                    )\n                                )\n                                .add(\n                                    new RedisBinder<>(\n                                        redisTemplate, \n                                        prop, \n                                        Duration.ofMinutes(5)\n                                    )\n                                )\n                                .build();\n                    }\n\n                    // `createResolverCache` is not overridden,\n                    // it always returns null, because\n                    // calculated property cache will not be \n                    // discussed in this article.\n                }\n            );\n        })\n        ...omit other configuration...\n        .build()\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Bean\nfun sqlClient(\n    redisTemplate: RedisTemplate<String, ByteArray>\n): KSqlClient =\n    newKSqlClient {\n        setCaches {\n            // highlight-next-line\n            setCacheFactory(\n\n                // Use this array to iterate types, \n                // association properties, and calculated properties.\n                arrayOf(\n                    BookStore.class,\n                    Book.class,\n                    Author.class,\n                    TreeNode.class\n                ),\n\n                // For each type and property, create optional cache.\n                object : CacheFactory {\n\n                    // Create object cache for types, including:\n                    // `BookStore`\n                    // `Book`\n                    // `Author`\n                    /// `TreeNode` \n                    override fun createObjectCache(type: ImmutableType): Cache<*, *>? =\n                        ChainCacheBuilder<Any, Any>()\n                            .add(\n                                CaffeineBinder(\n                                    512, \n                                    Duration.ofSeconds(1)\n                                )\n                            )\n                            .add(\n                                RedisBinder(\n                                    redisTemplate, \n                                    type, \n                                    Duration.ofMinutes(10)\n                                )\n                            )\n                            .build()\n\n                    // Create reference association cache for \n                    // one-to-one/many-to-one properties, including:\n                    // `Book.store`\n                    // `TreeNode.parent`\n                    override fun createAssociatedIdCache(prop: ImmutableProp): Cache<*, *>? =\n                        ChainCacheBuilder<Any, Any>()\n                            .add(\n                                CaffeineBinder(\n                                    512, \n                                    Duration.ofSeconds(1)\n                                )\n                            )\n                            .add(\n                                RedisBinder(\n                                    redisTemplate, \n                                    prop, \n                                    Duration.ofMinutes(5)\n                                )\n                            )\n                            .build()\n\n                    // Create list association cache for \n                    // one-to-many/many-to-many properties, including:\n                    // `BookStore.books`\n                    // `Book.authors`\n                    // `Author.books`\n                    // `TreeNode.childNodes`\n                    override fun createAssociatedIdListCache(prop: ImmutableProp): Cache<*, List<*>>? =\n                        ChainCacheBuilder<Any, List<*>>()\n                            .add(\n                                CaffeineBinder(\n                                    64, \n                                    Duration.ofSeconds(1)\n                                )\n                            )\n                            .add(\n                                RedisBinder(\n                                    redisTemplate, \n                                    prop, \n                                    Duration.ofMinutes(5)\n                                )\n                            )\n                            .build()\n\n                    // `createResolverCache` is not overridden,\n                    // it always returns null, because\n                    // calculated property cache will not be \n                    // discussed in this article.\n                }\n            )\n        }\n        ...omit other configuration...\n    }\n")))),(0,r.kt)("h3",{id:"explicit-configuration-overrides-implicit-configuration"},"Explicit configuration overrides implicit configuration"),(0,r.kt)("p",null,"While implicit configuration, which configures the cache for all types and all properties at once, is the recommended way, explicit configuration also has value."),(0,r.kt)("p",null,"If there are cache configurations in both explicit and implicit configurations for a type or property, the explicit configuration takes precedence.\nWhile implicit configuration, which configures the cache for all types and all properties at once, is the recommended way, explicit configuration also has value."),(0,r.kt)("p",null,"If there are cache configurations in both explicit and implicit configurations for a type or property, the explicit configuration takes precedence."),(0,r.kt)("h2",{id:"data-consistency"},"Data consistency"),(0,r.kt)("p",null,"The framework provides a solution to automatically guarantee consistency between databases and caches."),(0,r.kt)("h3",{id:"environmental-preparation"},"Environmental preparation"),(0,r.kt)("p",null,"To use this feature, the following steps are required."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Select a database that supports binlog, enable binlog."),(0,r.kt)("li",{parentName:"ol"},"Install kafka and create a topic."),(0,r.kt)("li",{parentName:"ol"},"Use some tools like maxwell, canal or DataBus to send binlog changes to the kafka topic created in the previous step")),(0,r.kt)("p",null,"You can click ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/babyfish-ct/jimmer/blob/main/example/env-with-cache/install.sh"},"here")," to see the docker install script of the examples."),(0,r.kt)("h3",{id:"ensure-data-consistency"},"Ensure data consistency"),(0,r.kt)("p",null,"To ensure data consistency is very simple, just listen to kafka events and call the relevant API."),(0,r.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Component\npublic class MaxwellListener {\n\n    private static final ObjectMapper MAPPER = new ObjectMapper();\n\n    private final Caches caches;\n\n    public MaxwellListener(JSqlClient sqlClient) {\n        this.caches = sqlClient.getCaches();\n    }\n\n    @KafkaListener(topics = "maxwell")\n    public void onHandle(\n            String json,\n            Acknowledgment acknowledgment\n    ) throws JsonProcessingException {\n        JsonNode node = MAPPER.readTree(json);\n        String tableName = node.get("table").asText();\n        if (caches.isAffectedBy(tableName)) {\n            String type = node.get("type").asText();\n            JsonNode data = node.get("data");\n            switch (type) {\n                case "insert":\n                    caches.invalidateByBinLog(tableName, null, data);\n                    break;\n                case "update":\n                    caches.invalidateByBinLog(\n                        tableName, \n                        node.get("old"), \n                        data\n                    );\n                    break;\n                case "delete":\n                    caches.invalidateByBinLog(tableName, data, null);\n                    break;\n            }\n        }\n        acknowledgment.acknowledge();\n    }\n}\n'))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Component\nclass MaxwellListener(sqlClient: KSqlClient) {\n\n    private val caches: KCaches = sqlClient.caches\n\n    @KafkaListener(topics = ["maxwell"])\n    fun onHandle(\n        json: String,\n        acknowledgment: Acknowledgment\n    ) {\n        val node = MAPPER.readTree(json)\n        val tableName = node["table"].asText()\n        if (caches.isAffectedBy(tableName)) {\n            val type = node["type"].asText()\n            val data = node["data"]\n            when (type) {\n                "insert" ->\n                    caches.invalidateByBinLog(tableName, null, data)\n                "update" ->\n                    caches.invalidateByBinLog(\n                        tableName, \n                        node["old"], \n                        data\n                    )\n                "delete" ->\n                    caches.invalidateByBinLog(tableName, data, null)\n            }\n        }\n        acknowledgment.acknowledge()\n    }\n\n    companion object {\n        private val MAPPER = ObjectMapper()\n    }\n}\n')))),(0,r.kt)("h3",{id:"experience-data-consistency"},"Experience data consistency"),(0,r.kt)("p",null,"So far, all the functions we have introduced are query-related, and modification-related functions have not been discussed yet. You can verify by directly executing SQL that modifies the data with any database tool."),(0,r.kt)("p",null,"In the above code, the second-level cache adapter ",(0,r.kt)("inlineCode",{parentName:"p"},"RedisBinder")," has log printing behavior internally, which can be used to quickly verify data consistency."),(0,r.kt)("h4",{id:"1-modify-foreign-key"},"1. Modify foreign key"),(0,r.kt)("p",null,"Execute"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"update book set store_id = 2 where id = 4\n")),(0,r.kt)("p",null,"Assuming that the foreign key before modification is 1, the log print result is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"delete from redis: [Book-4]\ndelete from redis: [BookStore.books-1]\ndelete from redis: [BookStore.books-2]\ndelete from redis: [Book.store-4]\n")),(0,r.kt)("p",null,"This indicates"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Object cache for ",(0,r.kt)("inlineCode",{parentName:"li"},"Book")," with id 4 is deleted"),(0,r.kt)("li",{parentName:"ul"},"The association cache for the one-to-many association ",(0,r.kt)("inlineCode",{parentName:"li"},"BookStore.books")," of ",(0,r.kt)("inlineCode",{parentName:"li"},"BookStore")," with id 1 is deleted"),(0,r.kt)("li",{parentName:"ul"},"The association cache for the one-to-many association ",(0,r.kt)("inlineCode",{parentName:"li"},"BookStore.books")," of ",(0,r.kt)("inlineCode",{parentName:"li"},"BookStore")," with id 2 is deleted"),(0,r.kt)("li",{parentName:"ul"},"The association cache for the many-to-one association ",(0,r.kt)("inlineCode",{parentName:"li"},"Book.store")," of ",(0,r.kt)("inlineCode",{parentName:"li"},"Book")," with id 4 is deleted")),(0,r.kt)("h4",{id:"2-modify-many-to-many-association-middle-table"},"2. Modify many-to-many association middle table"),(0,r.kt)("p",null,"Execute"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"insert into book_author_mapping(\n    book_id, author_id\n) values(\n    1, 4\n)\n")),(0,r.kt)("p",null,"the log print result is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"delete from redis: [Book.authors-1]\ndelete from redis: [Author.books-4]\n")),(0,r.kt)("p",null,"This indicates"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The association cache for the many-to-many association ",(0,r.kt)("inlineCode",{parentName:"li"},"Book.authors")," of ",(0,r.kt)("inlineCode",{parentName:"li"},"Book")," with id 1 is deleted"),(0,r.kt)("li",{parentName:"ul"},"The association cache for the many-to-many association ",(0,r.kt)("inlineCode",{parentName:"li"},"Author.books")," of ",(0,r.kt)("inlineCode",{parentName:"li"},"Author")," with id 4 is deleted")))}f.isMDXComponent=!0}}]);